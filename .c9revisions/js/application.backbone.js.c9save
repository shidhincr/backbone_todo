{"ts":1347526776803,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\r\n * App View is the skeleton of our code which controlls all the sub views\r\n * By default the App View events are attached to the body\r\n * This can be easily changed by overriding the 'el' property of the view.\r\n */\r\n(function($){\r\n    window.AppView = Backbone.View.extend({\r\n\r\n        el : \"body\"\r\n        /*\r\n         * Created two 'DIV' for holding the important tasks and normal tasks\r\n         * Caching the jQuery objects to the view so that we can use them later.\r\n         */\r\n        ,initialize : function( options ) {\r\n            this.textinput =  $(\"#taskText\");\r\n            this.main = $(\"#main\");\r\n            this.impomain = $(\"#priority\");\r\n\r\n            /**\r\n             * Listens to any changes in the global Tasks collection\r\n             * TODO :  make it more modular and remove the dependency from here\r\n             * Namespace the view \r\n             */\r\n\r\n            Tasks.on(\"add\",this.addSingleTask , this);\r\n            Tasks.on(\"change:important\",this.changePosition , this);\r\n\r\n            /**\r\n             * Calls the collections Fetch method to load all the tasks\r\n             * finally - render the Main View\r\n             */\r\n\r\n            Tasks.fetch();\r\n            this.render();\r\n        }\r\n        ,render : function(){\r\n            this.showAll();\r\n        }\r\n        ,events : {\r\n            \"click #addTask\" : \"addTask\"\r\n            ,\"keyup #taskText\": \"keyEnter\"\r\n        }\r\n        ,keyEnter: function(e){\r\n            if(e.keyCode === 13){\r\n                this.addTask();\r\n            }\r\n        }\r\n        ,addTask : function(){\r\n\r\n            /**\r\n             * Get the value from the text box and creates a task.\r\n             * Do the basic validations before creating the task - which can be done in task level also\r\n             * but i preferred it to be done here first.\r\n             */\r\n            var taskdesc = this.textinput.val();\r\n            this.textinput.removeClass(\"error\");\r\n\r\n            if( $.trim( taskdesc ) === \"\") {\r\n                this.textinput.addClass(\"error\").val(\"\");\r\n                return;\r\n            }\r\n            /**\r\n             * This is the easiest way of creating a new task - as our collection\r\n             * knows the structure of the model.\r\n             */\r\n            Tasks.create({\r\n                text : taskdesc\r\n            });\r\n\r\n            this.textinput.val(\"\").focus();\r\n\r\n        }\r\n        ,showAll : function(){\r\n            this.clearView();\r\n            Tasks.each( this.addSingleTask ,this);\r\n        }\r\n        ,showCompleted : function(){\r\n            this.clearView();\r\n            _.each(Tasks.completed(), this.addSingleTask ,this )\r\n        }\r\n        ,showImportant : function(){\r\n            this.clearView();\r\n            _.each(Tasks.important(), this.addSingleTask ,this )   \r\n        }\r\n        /**\r\n         * Adds a single View - by calling the TaskView \r\n         * @param  task [ raw JSON representation of the data]\r\n         */\r\n        ,addSingleTask : function( task ) {\r\n            var tview = new TaskView({\r\n                model: task\r\n            });\r\n            task.view = tview;\r\n            if(task.get(\"important\")){\r\n                tview.$el.appendTo( this.impomain ).fadeIn();\r\n            }else{\r\n                tview.$el.appendTo( this.main  ).fadeIn();\r\n            }\r\n        }\r\n        /**\r\n         * Check for the taks type , if its important then push it to the important DIV , else to the normal\r\n         * @param  {Task} task [currespoing task object]\r\n         * @return void\r\n         */\r\n        ,changePosition : function( task ){\r\n            ( task.get(\"important\") ) ? this.impomain.append( task.view.el ) : this.main.append( task.view.el );\r\n        }\r\n        /**\r\n         * Clear the view only ( no changes in the model )\r\n         * @return void\r\n         */\r\n        ,clearView : function(){\r\n            this.main.html(\"\");\r\n            this.impomain.html(\"\");\r\n        } \r\n\r\n    });\r\n\r\n}(jQuery));\r\n\r\n/**\r\n * Different routers for showing different views in the page\r\n * Yet to be impletemented completely.\r\n * But the method names describes them very well, i guess.\r\n */\r\n\r\nvar AppRouter = Backbone.Router.extend({\r\n    routes: {\r\n        \"\" :\"showAll\"\r\n        ,\"completed\": \"showCompleted\"\r\n        ,\"important\":\"showImportant\"\r\n    }\r\n    ,initialize : function(op){\r\n        this.view = op.view;\r\n    }\r\n    ,showCompleted : function(){\r\n        this.view.showCompleted();\r\n    }\r\n    ,showImportant : function(){\r\n        this.view.showImportant()\r\n    }\r\n    ,showAll : function(){\r\n        this.view.showAll();\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * The final code : \r\n * Initialise all the views and router when the DOM is ready.\r\n * TODO :  the routers are functional now , add the curresponding buttons to use them.\r\n */\r\n\r\njQuery(function(){\r\n    window.myTodoApp = new AppView;\r\n    window.myTodoRouter = new AppRouter({view : myTodoApp});\r\n    Backbone.history.start();\r\n});\r\n"]],"start1":0,"start2":0,"length1":0,"length2":4967}]],"length":4967}
